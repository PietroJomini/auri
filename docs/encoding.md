# Position and slides encoding

## Position

Each position, meaning a screenshot af a board in a given position, is encoded as
```
uint8 size;     // board size
uint8 stp;      // side to play
uint8 mc;       // played moves count

// bitboards
uint64 cbb[2];  // { .0 = white, .1 = black }
uint64 walls;
uint64 caps;

// stacks
// stacks are sorted with the highes piece in the lsb
uint64 stacks[64];
uint8 heights[64];

// remaining pieces
// { .0 = white, .i = black } { .0 = flats, .1 = caps }
uint8 reserves[2][2];
```

some notes:
- some bits are wasted, but the complexity of packing tighter the data is unlikely to be beneficial
- `uint64` fields are basically bitboards

## Slides

Given a stack made by `n` stones and no space constraints, the list of all possible slides using all the stones can be generated by iterating over the bitarray of the numbers in the range `[0, 2^(h-1)]` and reducing each number with (as pseudocode):

```
function reduce(bitarray):
    drops = []
    current_drop = 1

    for bit in bitarray:
        if bit is 1: // could also be 0, see below
            push current_drop into drops
            set current_drop to 1
        else:   
            add 1 to current_stack
    push current_stack into drops
```

For example, given a stack of height `h=4` we have `2^(h-1) = 2^3 = 8` possible configurations:

|     | bitarray | drops     |
| --- | -------- | --------- |
| `0` | `000`    | `4`       |
| `1` | `001`    | `3 1`     |
| `2` | `010`    | `2 2`     |
| `3` | `011`    | `2 1 1`   |
| `4` | `100`    | `1 3`     |
| `5` | `101`    | `1 2 1`   |
| `6` | `110`    | `1 1 2`   |
| `7` | `111`    | `1 1 1 1` |

To generate oll the possible slides, including the ones that leaves stones in the original square, we need to also consider the sub-stacks and their drop set. For example, given the same stack with `h=4` all the legal slides (with no space constraints) are:
- `0` stones left behind: `8` slides (as above)
- `1` stone left behind: `4` configurations resulting from the sub-stack with height `3`
- `2` stones left behind: `2` configurations resulting from the sub-stack with height `2`
- `3` stones left behind: `1` configuration resulting from the sub-stack with height `1`

for a total of `15` slides. This number is equal to `2^h - 1`.

> [!NOTE]
> while reducing, pushing a new stack at `1` or at `0` generate the same results, just in the opposite order (eg. the second slide will be the second to last).

> [!NOTE]
> if we count the amount of slides with length `n` and height `h` it results in the `h`-th row of a pascal triangle. For example, with `h=5`
> | n | # |
> | - | - |
> | 1 | 1 |
> | 2 | 4 |
> | 3 | 6 |
> | 4 | 4 |
> | 5 | 1 |
> 
> maybe this can be useful?

### Packing
Slide arrays can then be packed into a `int32`, where `s = [a, b, c, d, e, f, g, h]` becomes `i = 0x abcdefgh`.

### How many?
The number of packed slides required to configure every possible stack is equal the sum of the amount of configurations needed for each `h`, therefore the amount of possible slides needed for a stack of height `8`: `2^8 - 1`.