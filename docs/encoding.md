# Position and slides encoding

## Position

Each position, meaning a screenshot af a board in a given position, is encoded as
```
uint8 size;     // board size
uint8 stp;      // side to play
uint8 mc;       // played moves count

// bitboards
uint64 cbb[2];  // { .0 = white, .1 = black }
uint64 walls;
uint64 caps;

// stacks
// stacks are sorted with the highes piece in the lsb
uint64 stacks[64];
uint8 heights[64];

// remaining pieces
// { .0 = white, .i = black } { .0 = flats, .1 = caps }
uint8 reserves[2][2];
```

some notes:
- some bits are wasted, but the complexity of packing tighter the data is unlikely to be beneficial
- `uint64` fields are basically bitboards

## Slides

Given a stack made by `n` stones and no space constraints, the list of all possible slides can be generated by iterating over the bitarray of the numbers in the range `0..2^(h-1)` and reducing each number with (as pseudocode):
```
function reduce(bitarray):
    drops = []
    current_drop = 1

    for bit in bitarray:
        if bit is 1: // could also be 0
            push current_drop into drops
            set current_drop to 1
        else:   
            add 1 to current_stack
    push current_stack into drops
```
and then add the 0-prefixed slides to complete the set. The only exception is when the board size (and the the highest stack) is `8`, in which case we have to remove the only slide that spans over 9 cells (`0 1 1 1 1 1 1 1 1`).

Slide arrays can then be packed into a `int32`, where `s = [a, b, c, d, e, f, g, h]` becomes `i = 0x abcdefgh`.

> [!NOTE]
> while reducing, pushing a new stack at `1` or at `0` generate the same results, just in the opposite order (eg. the second slide will be the second to last).

> [!NOTE]
> if we count the amount of slides with length `n` and height `h` it results in the `h`-th row of a pascal triangle. For example, with `h=5`
> | n | # |
> | - | - |
> | 1 | 1 |
> | 2 | 4 |
> | 3 | 6 |
> | 4 | 4 |
> | 5 | 1 |
> 
> maybe this can be useful?

### Example

Given a stack of height `h=4` we have `2^h-1 = 2^3 = 8` possible configurations:

| i   | bitarray | drops    | 0-prefixed  |
| --- | -------- | -------- | ----------- |
| `0` | `000`    | `4`      | `0 4`       |
| `1` | `001`    | `3 1`    | `0 3 1`     |
| `2` | `010`    | `2 2`    | `0 2 2`     |
| `3` | `011`    | `2 1 1`  | `0 2 1 1`   |
| `4` | `100`    | `1 3`    | `0 1 3`     |
| `5` | `101`    | `1 2 1`  | `0 1 2 1`   |
| `6` | `110`    | `1 1 2`  | `0 1 1 2`   |
| `7` | `111`    | `1 1 1 ` | `0 1 1 1 1` |
