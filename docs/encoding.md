# Position and slides encoding

## Position

Each position, meaning a screenshot af a board in a given position, is encoded as
```c
uint8 size;     // board size
uint8 stp;      // side to play
uint8 mc;       // played moves count

// bitboards
uint64 cbb[2];  // { .0 = white, .1 = black }
uint64 walls;
uint64 caps;

// stacks
// stacks are sorted with the highes piece in the lsb
uint64 stacks[64];
uint8 heights[64];

// remaining pieces
// { .0 = white, .i = black } { .0 = flats, .1 = caps }
uint8 reserves[2][2];
```

some notes:
- some bits are wasted, but the complexity of packing tighter the data is unlikely to be beneficial

## Rotations

https://www.chessprogramming.org/Flipping_Mirroring_and_Rotating#Flip_and_Mirror

| rotation              | equivalent                 |
| --------------------- | -------------------------- |
| original              |                            |
| rotate +90            | mirror antidiag + mirror h |
| rotate 180            | mirror v + mirror h        |
| rotate -90            | mirror diag + mirror h     |
| mirror h              |                            |
| mirror h + rotate +90 | mirror antidiag            |
| mirror h + rotate 180 | mirror v                   |
| mirror h + rotate -90 | mirror diag                |

Probably it's ok to store 8 zobrist hash insthead of 8 different rotated positions, and update each hash with rotated indexes.

Even if that happens to be not enough, it shoudn't be hard to implement bitboard rotations for each size as series of delta swaps. For example, mirroring on 5s is:
```c
// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 ...
// a b c d e f g h i j k l m n o p q r s t u v w x y ...
// e d c b a j i h g f o n m l k t s r q p y z w v u ...
//
// swap 1: delta 4
//  from: 1000010000100001000010000
//    to: 0000100001000010000100001
// swap 2: delta 2
//  from: 0100001000010000100001000
//    to: 0001000010000100001000010
//
// there should be no need to reverse the numbers from above
// to the right endiannes, as they should be simmetrical
uint64_t mirror_h5(uint64_t n) {
    return (n & 0b1000010000100001000010000) >> 4 |
           (n & 0b0000100001000010000100001) << 4 |
           (n & 0b0100001000010000100001000) >> 2 |
           (n & 0b0001000010000100001000010) >> 2;
}

// 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 ...
// a b c d e f g h i j k l m n o p q r s t u v w x y ...
// u v w x y p q r s t o n m l k f g h i j a b c d e ...
// 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0 1 1 1 1 1 0 0 0 0 0
// 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
//
// swap 1: delta 20
//  from: 1111100000000000000000000
//    to: 0000000000000000000011111
// swap 2: delta 10
//  from: 0000011111000000000000000
//    to: 0000000000000001111100000
uint64_t mirror_v5(uint64_t n) {
    return (n & 0b1111100000000000000000000) >> 20 |
           (n & 0b0000000000000000000011111) << 20 |
           (n & 0b0000011111000000000000000) >> 10 |
           (n & 0b0000000000000001111100000) >> 10;
}
```

### Mirror horizontally

Given the board size $s$
$$
    m(n) = n - (n \mod s) + s \div 2
$$
gets the "middle" index of each row and
$$
    e(s) = 1 - (s \mod 2) \\
    n' = n + 2 * (m - n) - e(s)
$$
gives the mirrored index. The function above solves to
$$
    n' = n + ((s \div 2 - (n \mod s)) \ll 1) - e(s)
$$
When $s$ is a power of 2, it's possible to use
$$
    n' = n \oplus (s - 1)
$$

### Mirror vertically

Given the board size $s$
$$
    d(n) = s \div 2 - n \div s
$$
gives the vertical distance from the central row of the board (and an offset for even-sized boards), and
$$
    n' = n + 2s \cdot d(n) + s*e(s)
$$
gives the mirrored index. When $s$ is a power of 2, it's possible to use
$$
    n' = n \oplus s(s - 1)
$$

## Slides

Given a stack made by `n` stones and no space constraints, the list of all possible slides using all the stones can be generated by iterating over the bitarray of the numbers in the range `[0, 2^(h-1)]` and reducing each number with (as pseudocode):

```
function reduce(bitarray):
    drops = []
    current_drop = 1

    for bit in bitarray:
        if bit is 1: // could also be 0, see below
            push current_drop into drops
            set current_drop to 1
        else:   
            add 1 to current_stack
    push current_stack into drops
```

For example, given a stack of height `h=4` we have `2^(h-1) = 2^3 = 8` possible configurations:

|     | bitarray | drops     |
| --- | -------- | --------- |
| `0` | `000`    | `4`       |
| `1` | `001`    | `3 1`     |
| `2` | `010`    | `2 2`     |
| `3` | `011`    | `2 1 1`   |
| `4` | `100`    | `1 3`     |
| `5` | `101`    | `1 2 1`   |
| `6` | `110`    | `1 1 2`   |
| `7` | `111`    | `1 1 1 1` |

To generate oll the possible slides, including the ones that leaves stones in the original square, we need to also consider the sub-stacks and their drop set. For example, given the same stack with `h=4` all the legal slides (with no space constraints) are:
- `0` stones left behind: `8` slides (as above)
- `1` stone left behind: `4` configurations resulting from the sub-stack with height `3`
- `2` stones left behind: `2` configurations resulting from the sub-stack with height `2`
- `3` stones left behind: `1` configuration resulting from the sub-stack with height `1`

for a total of `15` slides. This number is equal to `2^h - 1`.

> [!NOTE]
> while reducing, pushing a new stack at `1` or at `0` generate the same results, just in the opposite order (eg. the second slide will be the second to last).

> [!NOTE]
> if we count the amount of slides with length `n` and height `h` it results in the `h`-th row of a pascal triangle. For example, with `h=5`
> | n | # |
> | - | - |
> | 1 | 1 |
> | 2 | 4 |
> | 3 | 6 |
> | 4 | 4 |
> | 5 | 1 |
> 
> maybe this can be useful?

### Packing
Slide arrays can then be packed into a `int32`, where `s = [a, b, c, d, e, f, g, h]` becomes `i = 0x abcdefgh`.

### How many?
The number of packed slides required to configure every possible stack is equal the sum of the amount of configurations needed for each `h`, therefore the amount of possible slides needed for a stack of height `8`: `2^8 - 1`.