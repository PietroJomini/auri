from typing import List
from itertools import chain

# slides can be obtained by counting and then reducing over the bitarray of the numbers
# eg. for a stack of height 4 we have 2^(h-1) = 2^3 = 8 possible configurations
#   0   000
#   1   001
#   2   010
#   3   011
#   4   100
#   5   101
#   6   110
#   7   111
#
# we can reduce over the bitarray with (as pseudocode):
#       stacks = []
#       current_stack = 1
#       iterate over bits:
#           if bit is 1:
#               push current_stack to stacks
#               set current_stack to 1
#           else:
#               add 1 to current_stack
#       push current_stack to stacks
#
# resulting in the stacks
#   0   000     4
#   1   001     3 1
#   2   010     2 2
#   3   011     2 1 1
#   4   100     1 3
#   5   101     1 2 1
#   6   110     1 1 2
#   7   111     1 1 1 1
#
# then we order by length and add the 0-prefixed slides
# resulting in 2^h slides configurations.
# the only exception is when h=8, in which case the only slide
# that spans over 9 cells can be removed (0 1 1 1 1 1 1 1 1).
#
# NOTE: if we count the amount of slides with length n with height h
#       it results in the h-th row of a pascal triangle. eg, h=5
#           length | amount
#                1 | 1
#                2 | 4
#                3 | 6
#                4 | 4
#                5 | 1
#       maybe this can be useful?
#
# TODO: slides can also be packed in b nibbles. taktician is doing
#       it, but is it worthy?


# reduce the nth slide with h stones
def stacks(h: int, n: int) -> List[int]:
    stack = [1]
    for i in range(h - 1):
        bit = n & (1 << i) == 0
        if bit:
            stack[-1] += 1
        else:
            stack.append(1)
    return stack


# transform a stack to a int32, where
#   s = [a, b, c, d, e, f, g, h]
#   i = 0x hgfedcba
def intify(s: List[int]) -> int:
    i = 0
    for h in reversed(s):
        i |= h
        i <<= 4
    return i >> 4


# generate all possible slides with h stones
def gen(h: int) -> List[int]:
    branches = [list(stacks(h, n)) for n in range(2 ** (h - 1))]
    branches += [[0, *b] for b in branches]
    branches.sort(key=lambda branch: len(branch))
    branches = filter(lambda b: len(b) <= 8, branches)
    return branches


# generate .c file
def gen_c():
    branches = list(chain(*map(gen, range(3, 9))))
    lengths = list(map(len, branches))
    indices = [i for i, n in enumerate(lengths) if n == 1]
    branches = map(intify, branches)
    cjoin = lambda l: "{" + ", ".join(map(str, l)) + "}"

    print("// clang-format off")
    print("")
    print("// DO NOT MANUALLY MODIFY")
    print("// automatically generated by `/scripts/slides.py`")
    print("")
    print('#include "slides.h"')
    print("#include <stdint.h>")
    print("")
    print(f"const uint8_t SLIDES_INDEX[6] = {cjoin(indices)};")
    print(f"const uint8_t SLIDES_LENGHT[SLIDES_AMOUNT] = {cjoin(lengths)};")
    print(f"const uint8_t SLIDES[SLIDES_AMOUNT] = {cjoin(branches)};")


if __name__ == "__main__":
    gen_c()
